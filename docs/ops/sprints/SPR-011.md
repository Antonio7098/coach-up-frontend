# Sprint SPR-011 — User Memory System (Semantic + Episodic)

Design and implement a Convex-first User Memory System powering personalization and assessment context: semantic facts/preferences/goals, episodic conversation summaries, and daily progress rollups with privacy-aware retention.

## Meta
- Sprint ID: SPR-011
- Status: in_progress
- Start date: 28/08/2025
- End date: 
- Links: [Overview](./overview.md) · [PRD](../../planning/prd2.md) · [Technical Overview](../../planning/technical-overview.md) · [Monitoring](../../ops/monitoring.md) · [Benchmarking](../../ops/benchmarking.md) · [Features CSV](../features.csv)

## Objectives (Tick when achieved)
- [ ] Define and land Convex schema for semantic facts, episodic summaries, daily progress, gamification, and privacy consents
- [ ] Implement minimal queries/mutations to read/write memory and fetch chat context under token budget
- [ ] Integrate backend AI API to persist episodic summaries and rollups on assessment completion
- [ ] Respect privacy/retention (TTL sweeps, delete-by-user) and document behavior

## Planned Tasks
- [ ] Convex schema + indexes — <owner> (1d)
  - [ ] Add collections: users_profile, users_privacy_consents, users_preferences, users_goals, users_memory_facts, users_memory_episodes, users_progress_daily, users_gamification
  - [ ] Update existing: tracked_skills (allow order 1..3; optional active flag)
  - [ ] Create secondary indexes (userId, compound for progress) and TTL on expiresAtMs
  - [ ] Update `convex/schema.ts` and run local typegen
- [ ] Convex functions (queries/mutations) — <owner> (2d)
  - [ ] mem.getContextForChat(userId, sessionId?) with token budget
  - [ ] mem.upsertPreference, mem.addGoal/updateGoal
  - [ ] mem.ingestEpisodeSummary, progress.upsertDaily, gamification.update
- [ ] Backend AI API integration — <owner> (2d)
  - [ ] On assessment finalize, POST to Convex mem.ingestEpisodeSummary and progress.upsertDaily
  - [ ] Secure Convex calls (reuse `CONVEX_URL`, timeouts) and log ctx_source
  - [ ] Unit tests for integration paths (mock Convex)
- [ ] Privacy & retention — <owner> (1d)
  - [ ] TTL purge via Convex cron on users_memory_episodes/users_memory_facts
  - [ ] Delete-by-user function covering all collections
  - [ ] Document settings and defaults
- [ ] UI wiring — <owner> (1d)
  - [ ] Use getContextForChat in chat SSE open when CLASSIFIER_CONTEXT_LIMIT set
  - [ ] Preferences screen (MVP fields: tone, verbosity, correctionStyle, TTS voice)

## Scope
In scope
- Convex data model and core CRUD for memory
- Backend write paths from assessments to episodic/progress
- Privacy/retention enforcement and delete-by-user
- Minimal UI hooks to fetch context and edit preferences

Out of scope
- Vector embeddings/ANN search (future V2)
- Advanced audio-derived features (prosody-specific facts) — placeholder tags only
- Cross-device offline sync

## Features in this Sprint
List feature IDs from Features CSV (pipe-separate multiple)
- [ ] FEAT-MEM-001 — User Memory System (core)
- [ ] FEAT-CHAT-CTX — Chat context from memory (classifier)

## Acceptance Criteria
- [ ] Convex schema compiled; typegen succeeds; migrations applied locally
- [ ] Backend assessments generate episodic summaries and daily rollups visible via queries
- [ ] getContextForChat returns curated facts + N recent episodes within CLASSIFIER_CONTEXT_LIMIT
- [ ] Privacy: TTL purges expired docs; delete-by-user removes all memory entries
- [ ] Unit tests cover Convex functions and backend integration (green)

## Risks & Mitigations
- Risk: Token bloat in chat context · Mitigation: strict token budgeting + ranking by weight/recency
- Risk: Privacy non-compliance · Mitigation: consents table, TTL, delete-by-user, docs
- Risk: Backend/Convex coupling and timeouts · Mitigation: timeouts + retries; graceful fallback to client history

## Dependencies
- Depends on features/sprints: SPR-002/SPR-006 (backend context builder, transcript persistence)
- External: Convex dev/prod environment; Clerk userId availability; env `CLASSIFIER_CONTEXT_LIMIT`

## Technical Details
### Database Models
- Collections/Tables impacted:
  - `users_profile`, `users_privacy_consents`, `users_preferences`, `users_goals`, `users_tracked_skills`
  - `users_memory_facts`, `users_memory_episodes`, `users_progress_daily`, `users_gamification`
- New/changed fields (key ones):
  - users_memory_facts: { factId: string, kind: "preference|bio|constraint|achievement|skill_hint", text: string, tags: string[], skillId?: string, weight: number, decayMs: number, createdAtMs: number, lastReinforcedAtMs: number, expiresAtMs?: number, source: string }
  - users_memory_episodes: { episodeId: string, sessionId?: string, groupId?: string, summary: string, highlights: {type: string, text: string, skillId?: string, scoreDelta?: number}[], startIdx?: number, endIdx?: number, createdAtMs: number, expiresAtMs?: number }
  - users_progress_daily: { dateYYYYMMDD: string, skillId: string, samples: number, avgLevel: number, xpEarned: number, medals: string[], errors: string[], tokensIn: number, tokensOut: number, costUsd: number, latencyMsTotal: number, updatedAtMs: number }
  - users_profile: { displayName?: string, email?: string, avatarUrl?: string, bio?: string, createdAt: number, updatedAt: number }
  - users_privacy_consents: { consent: string, granted: boolean, scope?: string, version?: string, createdAt: number, updatedAt: number, expiresAtMs?: number }
  - users_preferences: { tone?: string, verbosity?: "low|medium|high", correctionStyle?: "inline|summary", ttsVoice?: string, language?: string, extra?: any, updatedAt: number }
  - users_goals: { goalId: string, title: string, description?: string, status: "active|paused|completed", targetDateMs?: number, tags: string[], createdAt: number, updatedAt: number }
  - users_gamification: { xpTotal: number, level: number, streakDays: number, lastActivityYYYYMMDD?: string, badges: string[], seasonId?: string, seasonXp?: number, updatedAt: number }
  - tracked_skills (update): { order: 1..3; optional active flag; enforce ≤ 3 records per user }
- Constraints/validation:
  - `userId` required on all; `order` in tracked skills 1..3; `avgLevel` 1..10; non-negative counters
- Indexes (read/write paths):
  - All tables index by `userId`
  - `users_progress_daily` composite (userId, dateYYYYMMDD, skillId)
  - `users_memory_facts` (userId, kind), (userId, skillId), TTL on `expiresAtMs`
  - `users_memory_episodes` (userId, createdAtMs desc), TTL on `expiresAtMs`
- Migrations: NA (new collections)
- Data retention: Summaries/Facts per `retentionDays`; raw transcripts governed elsewhere

### Convex Schema Snippets (sketch)

```ts
// users_memory_facts
users_memory_facts: defineTable({
  userId: v.string(),
  factId: v.string(),
  kind: v.union(
    v.literal("preference"),
    v.literal("bio"),
    v.literal("constraint"),
    v.literal("achievement"),
    v.literal("skill_hint"),
  ),
  text: v.string(),
  tags: v.array(v.string()),
  skillId: v.optional(v.string()),
  weight: v.number(),
  decayMs: v.number(),
  createdAtMs: v.number(),
  lastReinforcedAtMs: v.number(),
  expiresAtMs: v.optional(v.number()),
  source: v.string(),
})
  .index("by_user", ["userId"]) 
  .index("by_user_kind", ["userId", "kind"]) 
  .index("by_user_skill", ["userId", "skillId"]) 
  .index("by_expiresAt", ["expiresAtMs"]);
```

```ts
// users_memory_episodes
users_memory_episodes: defineTable({
  userId: v.string(),
  episodeId: v.string(),
  sessionId: v.optional(v.string()),
  groupId: v.optional(v.string()),
  summary: v.string(),
  highlights: v.array(
    v.object({
      type: v.string(),
      text: v.string(),
      skillId: v.optional(v.string()),
      scoreDelta: v.optional(v.number()),
    })
  ),
  startIdx: v.optional(v.number()),
  endIdx: v.optional(v.number()),
  createdAtMs: v.number(),
  expiresAtMs: v.optional(v.number()),
})
  .index("by_user_created", ["userId", "createdAtMs"]) 
  .index("by_user_session", ["userId", "sessionId"]) 
  .index("by_user_group", ["userId", "groupId"]) 
  .index("by_expiresAt", ["expiresAtMs"]);
```

```ts
// users_progress_daily
users_progress_daily: defineTable({
  userId: v.string(),
  dateYYYYMMDD: v.string(),
  skillId: v.string(),
  samples: v.number(),
  avgLevel: v.number(),
  xpEarned: v.number(),
  medals: v.array(v.string()),
  errors: v.array(v.string()),
  tokensIn: v.number(),
  tokensOut: v.number(),
  costUsd: v.number(),
  latencyMsTotal: v.number(),
  updatedAtMs: v.number(),
})
  .index("by_user_date_skill", ["userId", "dateYYYYMMDD", "skillId"]) 
  .index("by_user_date", ["userId", "dateYYYYMMDD"]);
```

```ts
// users_gamification
users_gamification: defineTable({
  userId: v.string(),
  xpTotal: v.number(),
  level: v.number(),
  streakDays: v.number(),
  lastActivityYYYYMMDD: v.optional(v.string()),
  badges: v.array(v.string()),
  seasonId: v.optional(v.string()),
  seasonXp: v.optional(v.number()),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]);
```

```ts
// users_privacy_consents
users_privacy_consents: defineTable({
  userId: v.string(),
  consent: v.string(),
  granted: v.boolean(),
  scope: v.optional(v.string()),
  version: v.optional(v.string()),
  createdAt: v.number(),
  updatedAt: v.number(),
  expiresAtMs: v.optional(v.number()),
})
  .index("by_user_consent", ["userId", "consent"]) 
  .index("by_expiresAt", ["expiresAtMs"]);
```

```ts
// users_preferences
users_preferences: defineTable({
  userId: v.string(),
  tone: v.optional(v.string()),
  verbosity: v.optional(v.union(
    v.literal("low"),
    v.literal("medium"),
    v.literal("high"),
  )),
  correctionStyle: v.optional(v.union(
    v.literal("inline"),
    v.literal("summary"),
  )),
  ttsVoice: v.optional(v.string()),
  language: v.optional(v.string()),
  extra: v.optional(v.any()),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]);
```

```ts
// users_profile
users_profile: defineTable({
  userId: v.string(),
  displayName: v.optional(v.string()),
  email: v.optional(v.string()),
  avatarUrl: v.optional(v.string()),
  bio: v.optional(v.string()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]);
```

```ts
// tracked_skills (update contract: order 1..3; enforce in functions)
tracked_skills: defineTable({
  userId: v.string(),
  skillId: v.string(),
  currentLevel: v.number(), // 0..10
  order: v.number(), // 1..3
  // active: v.optional(v.boolean()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]) 
  .index("by_user_skill", ["userId", "skillId"]) 
  .index("by_user_order", ["userId", "order"]);
```

### Algorithmic Details
- Approach: Rank memories by effective score = f(weight, recency) and tags/skill match; budget tokens via `CLASSIFIER_CONTEXT_LIMIT`
- Rubric Version: v2-only assessments feed rollups
- Latency targets: TTFT < 1.2s; full-turn < 2.5s; assessment p95 < 8s

### Convex Function Surfaces
- mem.getContextForChat(userId, sessionId?, limitTokens?):
  - Returns `{ facts[], episodes[], ctx_source: "convex", tokensEstimated }`
  - Selection: top-k facts by weight×recency and tag/skill match; N most recent episodes
  - Budget using `CLASSIFIER_CONTEXT_LIMIT` with safety buffer
- mem.upsertPreference(userId, patch)
- mem.addGoal(userId, goal), mem.updateGoal(userId, goalId, patch)
- mem.ingestEpisodeSummary(payload) — called by backend on finalize
- progress.upsertDaily(userId, date, skillId, rollup)
- gamification.update(userId, { xpDelta, badgesToAdd? })
- admin.deleteByUser(userId) — hard-delete in all collections
- cron.ttlSweep() — purge expired by `expiresAtMs` indexes

### Compatibility Notes
- No collisions with existing Convex tables in `coach-up-frontend/convex/schema.ts`
- `tracked_skills` remains the same table; only business rule changes (≤3, order 1..3)
- Backlinks: `users_memory_episodes.sessionId|groupId` align with `sessions`/`assessments`
- Works with existing backend context flow: client `history` param preferred; falls back to Convex context when enabled

### Prompts & Rubrics
- Prompt usage: prepend curated facts + recent episodic summaries; annotate `ctx_source`
- Judge/rubric key points: clarity, persuasion, disfluency reduction, minimality, supportive tone

## QA & Testing
- [ ] Unit tests updated/added (Convex functions)
- [ ] E2E happy path green (Playwright) — chat with context on
- [ ] Load/SSE smoke test passes (k6) — unchanged budgets
- [ ] Contract tests for backend→Convex calls (mock server)

## Observability & SLOs
Targets (see Technical Overview §10)
- Realtime chat p95 TTFT < 1.2s; full-turn < 2.5s
- Assessment p95 completion < 8s

Checkpoints
- [ ] Dashboards updated: memory write rates, TTL purges, context token budget utilization
- [ ] Alerts configured: Convex error rate for mem.* and progress.* functions; context builder budget overruns
- [ ] Structured logs include requestId, userId, provider, modelId, tokens, cost, latency, ctx_source

## Issues & Deviations
Use this section to log issues encountered during the sprint, how they were resolved, and any deviations from the plan.

- Date:  — Issue:  — Impact: 
  - Detection: 
  - Fix:  — PR:  — Owner: 
  - Follow-up: 
- Deviation from plan: 

## Operational Hygiene
- [ ] CI checks green (API Docs workflow, tests/linting)
- [ ] Branch protection respected (PR + review)
- [ ] Pre-commit hooks executed (lint/format/type checks)
- [ ] .env.example updated if new env vars added
- [ ] Request ID propagated end-to-end for changed paths
- [ ] Logs include: requestId, route, userId (if available), provider, modelId, tokens, cost, latency
- [ ] Rate limiting and idempotency considered for new/changed endpoints

## Documentation
- [ ] API reference updated for endpoints touched (Core & AI)
- [ ] OpenAPI spec updated and linted
- [ ] Examples added/verified (curl + TypeScript)
- [ ] Cross-links updated (PRD/Technical Overview)

## Post-sprint
- [ ] KPIs reviewed; compare to targets
- [ ] Retrospective completed; action items filed
- [ ] Docs updated (PRD/Tech Overview/Runbooks)

## Change Log
- 28/08/2025 Created sprint page
- 29/08/2025 Added detailed Convex schema, function surfaces, TTL/indexing, and compatibility notes
- 29/08/2025 Verified episodic summary plumbing end-to-end in mock: session-summary API returns 404 when missing, mock seed can create a real summary for smoke tests, and `AudioContext` subscribes to `cu.audio.enqueue` emitted by `MicContext` for TTS playback.
