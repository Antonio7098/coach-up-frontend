# Sprint SPR-011 — User Memory System (Semantic + Episodic)

Design and implement a Convex-first User Memory System powering personalization and assessment context: semantic facts/preferences/goals, episodic conversation summaries, and daily progress rollups with privacy-aware retention.

## Meta
- Sprint ID: SPR-011
- Status: in_progress
- Start date: 28/08/2025
- End date: 
- Links: [Overview](./overview.md) · [PRD](../../planning/prd2.md) · [Technical Overview](../../planning/technical-overview.md) · [Monitoring](../../ops/monitoring.md) · [Benchmarking](../../ops/benchmarking.md) · [Features CSV](../features.csv)

## Objectives (Tick when achieved)
- [ ] Define and land Convex schema for semantic facts, episodic summaries, daily progress, gamification, and privacy consents
- [ ] Implement minimal queries/mutations to read/write memory and fetch chat context under token budget
- [ ] Integrate backend AI API to persist episodic summaries and rollups on assessment completion
- [ ] Respect privacy/retention (TTL sweeps, delete-by-user) and document behavior

## Planned Tasks
- [ ] Convex schema + indexes — <owner> (1d)
  - [ ] Add collections: users_profile, users_privacy_consents, users_preferences, users_goals, users_memory_facts, users_memory_episodes, users_progress_daily, users_gamification
  - [ ] Update existing: tracked_skills (allow order 1..3; optional active flag)
  - [ ] Create secondary indexes (userId, compound for progress) and TTL on expiresAtMs
  - [ ] Update `convex/schema.ts` and run local typegen
- [ ] Convex functions (queries/mutations) — <owner> (2d)
  - [ ] mem.getContextForChat(userId, sessionId?) with token budget
  - [ ] mem.upsertPreference, mem.addGoal/updateGoal
  - [ ] mem.ingestEpisodeSummary, progress.upsertDaily, gamification.update
- [ ] Backend AI API integration — <owner> (2d)
  - [ ] On assessment finalize, POST to Convex mem.ingestEpisodeSummary and progress.upsertDaily
  - [ ] Secure Convex calls (reuse `CONVEX_URL`, timeouts) and log ctx_source
  - [ ] Unit tests for integration paths (mock Convex)
- [ ] Privacy & retention — <owner> (1d)
  - [ ] TTL purge via Convex cron on users_memory_episodes/users_memory_facts
  - [ ] Delete-by-user function covering all collections
  - [ ] Document settings and defaults
- [ ] UI wiring — <owner> (1d)
  - [ ] Use getContextForChat in chat SSE open when CLASSIFIER_CONTEXT_LIMIT set
  - [ ] Preferences screen (MVP fields: tone, verbosity, correctionStyle, TTS voice)

## Scope
In scope
- Convex data model and core CRUD for memory
- Backend write paths from assessments to episodic/progress
- Privacy/retention enforcement and delete-by-user
- Minimal UI hooks to fetch context and edit preferences

Out of scope
- Vector embeddings/ANN search (future V2)
- Advanced audio-derived features (prosody-specific facts) — placeholder tags only
- Cross-device offline sync

## Features in this Sprint
List feature IDs from Features CSV (pipe-separate multiple)
- [ ] FEAT-MEM-001 — User Memory System (core)
- [ ] FEAT-CHAT-CTX — Chat context from memory (classifier)

## Acceptance Criteria
- [ ] Convex schema compiled; typegen succeeds; migrations applied locally
- [ ] Backend assessments generate episodic summaries and daily rollups visible via queries
- [ ] getContextForChat returns curated facts + N recent episodes within CLASSIFIER_CONTEXT_LIMIT
- [ ] Privacy: TTL purges expired docs; delete-by-user removes all memory entries
- [ ] Unit tests cover Convex functions and backend integration (green)

## Risks & Mitigations
- Risk: Token bloat in chat context · Mitigation: strict token budgeting + ranking by weight/recency
- Risk: Privacy non-compliance · Mitigation: consents table, TTL, delete-by-user, docs
- Risk: Backend/Convex coupling and timeouts · Mitigation: timeouts + retries; graceful fallback to client history

## Dependencies
- Depends on features/sprints: SPR-002/SPR-006 (backend context builder, transcript persistence)
- External: Convex dev/prod environment; Clerk userId availability; env `CLASSIFIER_CONTEXT_LIMIT`

## Technical Details
### Database Models
- Collections/Tables impacted:
  - `users_profile`, `users_privacy_consents`, `users_preferences`, `users_goals`, `users_tracked_skills`
  - `users_memory_facts`, `users_memory_episodes`, `users_progress_daily`, `users_gamification`
- New/changed fields (key ones):
  - users_memory_facts: { factId: string, kind: "preference|bio|constraint|achievement|skill_hint", text: string, tags: string[], skillId?: string, weight: number, decayMs: number, createdAtMs: number, lastReinforcedAtMs: number, expiresAtMs?: number, source: string }
  - users_memory_episodes: { episodeId: string, sessionId?: string, groupId?: string, summary: string, highlights: {type: string, text: string, skillId?: string, scoreDelta?: number}[], startIdx?: number, endIdx?: number, createdAtMs: number, expiresAtMs?: number }
  - users_progress_daily: { dateYYYYMMDD: string, skillId: string, samples: number, avgLevel: number, xpEarned: number, medals: string[], errors: string[], tokensIn: number, tokensOut: number, costUsd: number, latencyMsTotal: number, updatedAtMs: number }
  - users_profile: { displayName?: string, email?: string, avatarUrl?: string, bio?: string, createdAt: number, updatedAt: number }
  - users_privacy_consents: { consent: string, granted: boolean, scope?: string, version?: string, createdAt: number, updatedAt: number, expiresAtMs?: number }
  - users_preferences: { tone?: string, verbosity?: "low|medium|high", correctionStyle?: "inline|summary", ttsVoice?: string, language?: string, extra?: any, updatedAt: number }
  - users_goals: { goalId: string, title: string, description?: string, status: "active|paused|completed", targetDateMs?: number, tags: string[], createdAt: number, updatedAt: number }
  - users_gamification: { xpTotal: number, level: number, streakDays: number, lastActivityYYYYMMDD?: string, badges: string[], seasonId?: string, seasonXp?: number, updatedAt: number }
  - tracked_skills (update): { order: 1..3; optional active flag; enforce ≤ 3 records per user }
- Constraints/validation:
  - `userId` required on all; `order` in tracked skills 1..3; `avgLevel` 1..10; non-negative counters
- Indexes (read/write paths):
  - All tables index by `userId`
  - `users_progress_daily` composite (userId, dateYYYYMMDD, skillId)
  - `users_memory_facts` (userId, kind), (userId, skillId), TTL on `expiresAtMs`
  - `users_memory_episodes` (userId, createdAtMs desc), TTL on `expiresAtMs`
- Migrations: NA (new collections)
- Data retention: Summaries/Facts per `retentionDays`; raw transcripts governed elsewhere

### Convex Schema Snippets (sketch)

```ts
// users_memory_facts
users_memory_facts: defineTable({
  userId: v.string(),
  factId: v.string(),
  kind: v.union(
    v.literal("preference"),
    v.literal("bio"),
    v.literal("constraint"),
    v.literal("achievement"),
    v.literal("skill_hint"),
  ),
  text: v.string(),
  tags: v.array(v.string()),
  skillId: v.optional(v.string()),
  weight: v.number(),
  decayMs: v.number(),
  createdAtMs: v.number(),
  lastReinforcedAtMs: v.number(),
  expiresAtMs: v.optional(v.number()),
  source: v.string(),
})
  .index("by_user", ["userId"]) 
  .index("by_user_kind", ["userId", "kind"]) 
  .index("by_user_skill", ["userId", "skillId"]) 
  .index("by_expiresAt", ["expiresAtMs"]);
```

```ts
// users_memory_episodes
users_memory_episodes: defineTable({
  userId: v.string(),
  episodeId: v.string(),
  sessionId: v.optional(v.string()),
  groupId: v.optional(v.string()),
  summary: v.string(),
  highlights: v.array(
    v.object({
      type: v.string(),
      text: v.string(),
      skillId: v.optional(v.string()),
      scoreDelta: v.optional(v.number()),
    })
  ),
  startIdx: v.optional(v.number()),
  endIdx: v.optional(v.number()),
  createdAtMs: v.number(),
  expiresAtMs: v.optional(v.number()),
})
  .index("by_user_created", ["userId", "createdAtMs"]) 
  .index("by_user_session", ["userId", "sessionId"]) 
  .index("by_user_group", ["userId", "groupId"]) 
  .index("by_expiresAt", ["expiresAtMs"]);
```

```ts
// users_progress_daily
users_progress_daily: defineTable({
  userId: v.string(),
  dateYYYYMMDD: v.string(),
  skillId: v.string(),
  samples: v.number(),
  avgLevel: v.number(),
  xpEarned: v.number(),
  medals: v.array(v.string()),
  errors: v.array(v.string()),
  tokensIn: v.number(),
  tokensOut: v.number(),
  costUsd: v.number(),
  latencyMsTotal: v.number(),
  updatedAtMs: v.number(),
})
  .index("by_user_date_skill", ["userId", "dateYYYYMMDD", "skillId"]) 
  .index("by_user_date", ["userId", "dateYYYYMMDD"]);
```

```ts
// users_gamification
users_gamification: defineTable({
  userId: v.string(),
  xpTotal: v.number(),
  level: v.number(),
  streakDays: v.number(),
  lastActivityYYYYMMDD: v.optional(v.string()),
  badges: v.array(v.string()),
  seasonId: v.optional(v.string()),
  seasonXp: v.optional(v.number()),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]);
```

```ts
// users_privacy_consents
users_privacy_consents: defineTable({
  userId: v.string(),
  consent: v.string(),
  granted: v.boolean(),
  scope: v.optional(v.string()),
  version: v.optional(v.string()),
  createdAt: v.number(),
  updatedAt: v.number(),
  expiresAtMs: v.optional(v.number()),
})
  .index("by_user_consent", ["userId", "consent"]) 
  .index("by_expiresAt", ["expiresAtMs"]);
```

```ts
// users_preferences
users_preferences: defineTable({
  userId: v.string(),
  tone: v.optional(v.string()),
  verbosity: v.optional(v.union(
    v.literal("low"),
    v.literal("medium"),
    v.literal("high"),
  )),
  correctionStyle: v.optional(v.union(
    v.literal("inline"),
    v.literal("summary"),
  )),
  ttsVoice: v.optional(v.string()),
  language: v.optional(v.string()),
  extra: v.optional(v.any()),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]);
```

```ts
// users_profile
users_profile: defineTable({
  userId: v.string(),
  displayName: v.optional(v.string()),
  email: v.optional(v.string()),
  avatarUrl: v.optional(v.string()),
  bio: v.optional(v.string()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]);
```

```ts
// tracked_skills (update contract: order 1..3; enforce in functions)
tracked_skills: defineTable({
  userId: v.string(),
  skillId: v.string(),
  currentLevel: v.number(), // 0..10
  order: v.number(), // 1..3
  // active: v.optional(v.boolean()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"]) 
  .index("by_user_skill", ["userId", "skillId"]) 
  .index("by_user_order", ["userId", "order"]);
```

### Algorithmic Details
- Approach: Rank memories by effective score = f(weight, recency) and tags/skill match; budget tokens via `CLASSIFIER_CONTEXT_LIMIT`
- Rubric Version: v2-only assessments feed rollups
- Latency targets: TTFT < 1.2s; full-turn < 2.5s; assessment p95 < 8s

### Convex Function Surfaces
- mem.getContextForChat(userId, sessionId?, limitTokens?):
  - Returns `{ facts[], episodes[], ctx_source: "convex", tokensEstimated }`
  - Selection: top-k facts by weight×recency and tag/skill match; N most recent episodes
  - Budget using `CLASSIFIER_CONTEXT_LIMIT` with safety buffer
- mem.upsertPreference(userId, patch)
- mem.addGoal(userId, goal), mem.updateGoal(userId, goalId, patch)
- mem.ingestEpisodeSummary(payload) — called by backend on finalize
- progress.upsertDaily(userId, date, skillId, rollup)
- gamification.update(userId, { xpDelta, badgesToAdd? })
- admin.deleteByUser(userId) — hard-delete in all collections
- cron.ttlSweep() — purge expired by `expiresAtMs` indexes

### Compatibility Notes
- No collisions with existing Convex tables in `coach-up-frontend/convex/schema.ts`
- `tracked_skills` remains the same table; only business rule changes (≤3, order 1..3)
- Backlinks: `users_memory_episodes.sessionId|groupId` align with `sessions`/`assessments`
- Works with existing backend context flow: client `history` param preferred; falls back to Convex context when enabled

### Prompts & Rubrics
- Prompt usage: prepend curated facts + recent episodic summaries; annotate `ctx_source`
- Judge/rubric key points: clarity, persuasion, disfluency reduction, minimality, supportive tone

## QA & Testing
- [x] Unit tests updated/added (Convex functions) - 21/21 tests passing
- [ ] E2E happy path green (Playwright) — chat with context on
- [ ] Load/SSE smoke test passes (k6) — unchanged budgets
- [ ] Contract tests for backend→Convex calls (mock server)

### Detailed Testing Plan
#### Unit Tests - COMPLETED ✅
- **Goals Functions Tested**: `getUserGoals`, `createGoal`, `updateGoal`, `deleteGoal` (CRUD operations with status enums, tags)
- **Profile Functions Tested**: `getUserProfile`, `updateUserProfile` (CRUD operations with validation)
- **Schema Constraints Validated**: Indexes properly configured (`by_user`, `by_user_goal`); field validation working
- **Edge Cases Covered**: Empty titles, length limits, non-existent goals, invalid email formats, ownership validation
- **API Integration Tested**: Full CRUD flow through API routes with both mock and real Convex clients
- **Results**: 31/31 tests passing (100% success rate) - 21 Convex function tests + 10 API integration tests

#### Integration Tests - PARTIALLY COMPLETED ✅ (Goals/Profile only)
- **Goals/Profile Integration Tested**: Full CRUD cycle through API routes to Convex functions
- **API→Convex Proxying Verified**: Both mock and real Convex clients tested
- **Error Handling Confirmed**: 502 errors properly handled for Convex failures
- **Rate Limiting Tested**: Request throttling working correctly
- **Authentication Integration**: User context properly passed through API layers

#### E2E Tests (Playwright)
- Happy Path: Enable memory → chat SSE pulls context → facts/episodes in responses; verify goals/profile via preferences screen.
- Scenarios: Add goal → update status → check in memory queries; test delete-by-user (privacy purge).
- Chat Integration: End-to-end assessment → episodic summary/daily progress persists.
- Tools: Playwright; focus on Coach-min UI.

#### Smoke Tests
- Quick sanity: Deploy schema → run `getContextForChat` → no errors; test goals/profile CRUD via UI.
- Tools: k6 for load; manual queries.

## Observability & SLOs
Targets (see Technical Overview §10)
- Realtime chat p95 TTFT < 1.2s; full-turn < 2.5s
- Assessment p95 completion < 8s

Checkpoints
- [x] Goals/Profile API monitoring: Metrics and logging already instrumented via existing Prometheus setup
- [x] API error rate monitoring: 502 errors for Convex failures tracked via `coachup_ui_api_request_errors_total`
- [x] Request latency monitoring: p95 tracked via `coachup_ui_api_request_duration_seconds`
- [ ] Structured logs include requestId, userId, provider, modelId, tokens, cost, latency, ctx_source

### Detailed Monitoring Plan (Prometheus/Grafana)
#### Metrics to Collect (via Prometheus) - IMPLEMENTED ✅
- **Goals/Profile API**: Already instrumented via existing metrics system:
  - `coachup_ui_api_requests_total{route="/api/v1/users/goals"}` - request counts
  - `coachup_ui_api_requests_total{route="/api/v1/users/profile"}` - request counts
  - `coachup_ui_api_request_errors_total{route="/api/v1/users/goals",status="502"}` - Convex failures
  - `coachup_ui_api_request_errors_total{route="/api/v1/users/profile",status="502"}` - Convex failures
  - `coachup_ui_api_request_duration_seconds{route="/api/v1/users/goals"}` - latency histogram
  - `coachup_ui_api_request_duration_seconds{route="/api/v1/users/profile"}` - latency histogram
- **Memory Operations**: `memory_facts_ingested_total`, `episodes_purged_total` (TTL sweeps); context fetch latency for `getContextForChat`.
- **Token Budget**: `context_tokens_used / CLASSIFIER_CONTEXT_LIMIT` (utilization); budget overruns.
- **Privacy**: `privacy_deletes_total` (delete-by-user); TTL purge rates.
- **Chat Integration**: `chat_context_fetched_total{ctx_source}`; latency for context pulls.
- **Metrics exposed via `/api/metrics` endpoint**

#### Grafana Dashboards
- Memory Health: Fact/episode counts; purge rates; token utilization charts.
- Goals/Profile: Engagement metrics (goals active/completed); preference update trends.
- Alerts: Token overruns; high error rates on mem.* functions; privacy deletes.
- Setup: Scrape from Convex/backend; build on existing dashboards.

#### Alerts & SLOs
- Alerts: Budget >90%; Convex errors on memory functions; TTL purge failures.
- SLOs: p95 TTFT <1.2s; assessment <8s; 99% uptime for queries.
- Logs: Include userId, ctx_source, tokens; redact sensitive data.

## Issues & Deviations
Use this section to log issues encountered during the sprint, how they were resolved, and any deviations from the plan.

- Date:  — Issue:  — Impact: 
  - Detection: 
  - Fix:  — PR:  — Owner: 
  - Follow-up: 
- Deviation from plan: 

## Operational Hygiene
- [ ] CI checks green (API Docs workflow, tests/linting)
- [ ] Branch protection respected (PR + review)
- [ ] Pre-commit hooks executed (lint/format/type checks)
- [ ] .env.example updated if new env vars added
- [ ] Request ID propagated end-to-end for changed paths
- [ ] Logs include: requestId, route, userId (if available), provider, modelId, tokens, cost, latency
- [ ] Rate limiting and idempotency considered for new/changed endpoints

## Documentation
- [ ] API reference updated for endpoints touched (Core & AI)
- [ ] OpenAPI spec updated and linted
- [ ] Examples added/verified (curl + TypeScript)
- [ ] Cross-links updated (PRD/Technical Overview)

## Post-sprint
- [ ] KPIs reviewed; compare to targets
- [ ] Retrospective completed; action items filed
- [ ] Docs updated (PRD/Tech Overview/Runbooks)

## Change Log
- 28/08/2025 Created sprint page
- 29/08/2025 Added detailed Convex schema, function surfaces, TTL/indexing, and compatibility notes
- 29/08/2025 Verified episodic summary plumbing end-to-end in mock: session-summary API returns 404 when missing, mock seed can create a real summary for smoke tests, and `AudioContext` subscribes to `cu.audio.enqueue` emitted by `MicContext` for TTS playback.
